exit
unsolved_numbers.count
exit
unsolved_numbers.count
exit
unsolved_numbers.count
exit
zeroes
exit
zeroes.flatten
zeroes
exit
rows.values.flatten.count
rows.values.count
rows.values
rows.count
rows
exit
cols
rows
n
s_num
exit
self
excluded_row_nums
excluded_col_nums
exit
s_num
number
n
number
s_num
exit
s_num
exit
subgroups.items.select { |sg, _| sg == number.subgroup }.values.flatten.each do |num|
subgroups.items.select { |sg, _| sg == number.subgroup }.values.flatten
subgroups.items.select { |sg, _| sg == number.subgroup }.values
subgroups.items.select { |sg, _| sg == number.subgroup }
s_num
exit
number.subgroup
items.first
items.count
items
exit
valid?
solved?
values
exit
solved?
numbers.map(&:value).each_slice(9).each { |r| puts r.inspect }
numbers.count
numbers.map(&:value).each_cons(9).each { |r| puts r.inspect }
numbers.map(&:value)
numbers.count
numbers
unsolved_numbers.count
exit
number.hidden_single_value(values)
values
exit
unsolved_numbers.count
hidden_singles
exit
unsolved_numbers.count
unsolved_numbers.first
unsolved_numbers
exit
assign_possible_values!
unsolved_numbers.count
unsolved_numbers
rows.first
rows
rows.items.each { |row| row.values.map(&:value) }
rows.itemseach { |row| row.values.map(&:value) }
rows.each { |row| row.values.map(&:value) }
rows.numbers
rows
rows.items.map { |k, v| v.value }
rows.items.map { |k, v| v }.map(&:value)
rows.items.map { |k, v| v }.first
rows.items.map { |k, v| v }
rows.items.first
rows.items
rows.items.map(&:value).each_cons(9) { |r| puts r.inspect }
rows.items
rows.first
rows
rows.map(&:value).each_cons(9).map { |n| puts n.inspect }
numbers.map(&:value).each_cons(9).map { |n| puts n.inspect }
exit
numbers.map(&:value).each_slice(9).each { |row| puts row.inspect }
numbers.map(&:value).each_slice(9).each { |row| puts row }
numbers.map(&:value).each_slice(9).to_a
numbers.map(&:value).each_slice(9)
numbers.map(&:value)
numbers.first
rows.items.first
rows.items
rows
rows[0]
rows.first
rows
rows_valid?
solved?
numbers.last
unsolved_numbers.count
solve_hidden_singles!
assign_possible_values!
solve_hidden_singles!
assign_possible_values!
exit
unsolved_numbers.count
assign_possible_values!
solve_hidden_singles!
unsolved_numbers.count
exit
unsolved_numbers.count
n
unsolved_numbers.count
exit
unsolved_numbers.count
exit
unsolved_numbers.size
n
exit
unsolved_numbers.count
n
unsolved_numbers.count
n
unsolved_numbers.count
unsolved_numbers
exit
hidden_singles
number
exit
number.possible_values
possible_values
columns.other_possible_values(number)
hidden_singles
exit
columns.other_possible_values(number).exit
columns.other_possible_values(number).count
columns.other_possible_values(number)
hidden_singles
exit
subgroups.other_numbers(number)
columns.other_numbers(number).size
columns.other_numbers(number)
rows.other_numbers(number)
number
exit
hidden_singles
number
exit
hidden_singles
exit
numbers[0]
number
a
exit
rows.first
rows
rows[0]
exit
items.first
items
exit
"one".pluralize
exit
number
possible_values_for(number)
exit
item
exit
items.each { |key, value| puts key.inspect; nil }
items.each { |key, value| puts key.inspect }; nil
items.each { |key, value| puts key.inspect; nil }
items.each { |key, value| puts key }
items.each do |key, value|
items
items.first.values
items.first
exit
items.values.flatten.map(&:value)
items.values.flatten
items.values.map(&:value)
items.values
exit
items.values.first
items.values
items.first
items
exit
items
items.values
exit
rows.first
rows
row
subgroups
columns
rows
exit
self.type
numbers.first
numbers.count
numbers
self
exit
numbers.values
numbers.first
name
numbers
numbers.values.first
numbers.values.map(&:value)
numbers.values
numbers.count
numbers.first
numbers
exit
numbers.group_by(&number_attribute)
exit
numbers.group_by(&name)
numbers.group_by(&:number_attribute)
numbers.group_by(&number_attribute)
numbers.group_by(number_attribute)
numbers
number_attribute.call
number_attribute
numbers.group_by number_attribute
exit
numbers.group_by { |x| x.x }
&:x
numbers.group_by(&:x)
number_attribute
numbers.group_by(number_attribute)
numbers.group_by number_attribute
exit
name.to_proc
name
number_attribute.call
numbers.group_by number_attribute.call
numbers.group_by &number_attribute
number_attribute
numbers.group_by number_attribute
exit
SudokuItem.rows_for(numbers)
exit
rows.numbers
rows
exit
rows.numbers.first
rows.numbers
rows.count
